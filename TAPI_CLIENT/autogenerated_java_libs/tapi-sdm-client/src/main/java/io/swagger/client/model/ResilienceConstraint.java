/*
 * tapi-sdm API
 * tapi-sdm API generated from tapi-sdm.yang
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.swagger.client.model.ResilienceType;
import java.io.IOException;

/**
 * A list of control parameters to apply to a switch.
 */
@ApiModel(description = "A list of control parameters to apply to a switch.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-08-08T09:23:18.099+02:00")
public class ResilienceConstraint {
  @SerializedName("max-switch-times")
  private String maxSwitchTimes = null;

  @SerializedName("wait-to-revert-time")
  private String waitToRevertTime = null;

  /**
   * Indicate which layer this resilience parameters package configured for.
   */
  @JsonAdapter(LayerProtocolEnum.Adapter.class)
  public enum LayerProtocolEnum {
    OTSIA("OTSiA"),
    
    OCH("OCH"),
    
    OTU("OTU"),
    
    ODU("ODU"),
    
    ETH("ETH"),
    
    ETY("ETY"),
    
    SDM("SDM"),
    
    DSR("DSR");

    private String value;

    LayerProtocolEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LayerProtocolEnum fromValue(String text) {
      for (LayerProtocolEnum b : LayerProtocolEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<LayerProtocolEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LayerProtocolEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LayerProtocolEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return LayerProtocolEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("layer-protocol")
  private LayerProtocolEnum layerProtocol = null;

  @SerializedName("restore-priority")
  private String restorePriority = null;

  @SerializedName("is-lock-out")
  private Boolean isLockOut = null;

  @SerializedName("is-coordinated-switching-both-ends")
  private Boolean isCoordinatedSwitchingBothEnds = null;

  @SerializedName("is-frozen")
  private Boolean isFrozen = null;

  /**
   * Indcates whether the protection scheme is revertive or non-revertive.
   */
  @JsonAdapter(ReversionModeEnum.Adapter.class)
  public enum ReversionModeEnum {
    REVERTIVE("REVERTIVE"),
    
    NON_REVERTIVE("NON-REVERTIVE");

    private String value;

    ReversionModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ReversionModeEnum fromValue(String text) {
      for (ReversionModeEnum b : ReversionModeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ReversionModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ReversionModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ReversionModeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ReversionModeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("reversion-mode")
  private ReversionModeEnum reversionMode = null;

  @SerializedName("hold-off-time")
  private String holdOffTime = null;

  @SerializedName("resilience-type")
  private ResilienceType resilienceType = null;

  /**
   *  The coordination mechanism between multi-layers.
   */
  @JsonAdapter(RestorationCoordinateTypeEnum.Adapter.class)
  public enum RestorationCoordinateTypeEnum {
    NO_COORDINATE("NO_COORDINATE"),
    
    HOLD_OFF_TIME("HOLD_OFF_TIME"),
    
    WAIT_FOR_NOTIFICATION("WAIT_FOR_NOTIFICATION");

    private String value;

    RestorationCoordinateTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RestorationCoordinateTypeEnum fromValue(String text) {
      for (RestorationCoordinateTypeEnum b : RestorationCoordinateTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<RestorationCoordinateTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RestorationCoordinateTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RestorationCoordinateTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return RestorationCoordinateTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("restoration-coordinate-type")
  private RestorationCoordinateTypeEnum restorationCoordinateType = null;

  public ResilienceConstraint maxSwitchTimes(String maxSwitchTimes) {
    this.maxSwitchTimes = maxSwitchTimes;
    return this;
  }

   /**
   * Used to limit the maximum swtich times. When work fault disappears , and traffic return to the original work path, switch counter reset.
   * @return maxSwitchTimes
  **/
  @ApiModelProperty(value = "Used to limit the maximum swtich times. When work fault disappears , and traffic return to the original work path, switch counter reset.")
  public String getMaxSwitchTimes() {
    return maxSwitchTimes;
  }

  public void setMaxSwitchTimes(String maxSwitchTimes) {
    this.maxSwitchTimes = maxSwitchTimes;
  }

  public ResilienceConstraint waitToRevertTime(String waitToRevertTime) {
    this.waitToRevertTime = waitToRevertTime;
    return this;
  }

   /**
   * If the protection system is revertive, this attribute specifies the time, in minutes, to wait after a fault clears on a higher priority (preferred) resource before reverting to the preferred resource.
   * @return waitToRevertTime
  **/
  @ApiModelProperty(value = "If the protection system is revertive, this attribute specifies the time, in minutes, to wait after a fault clears on a higher priority (preferred) resource before reverting to the preferred resource.")
  public String getWaitToRevertTime() {
    return waitToRevertTime;
  }

  public void setWaitToRevertTime(String waitToRevertTime) {
    this.waitToRevertTime = waitToRevertTime;
  }

  public ResilienceConstraint layerProtocol(LayerProtocolEnum layerProtocol) {
    this.layerProtocol = layerProtocol;
    return this;
  }

   /**
   * Indicate which layer this resilience parameters package configured for.
   * @return layerProtocol
  **/
  @ApiModelProperty(value = "Indicate which layer this resilience parameters package configured for.")
  public LayerProtocolEnum getLayerProtocol() {
    return layerProtocol;
  }

  public void setLayerProtocol(LayerProtocolEnum layerProtocol) {
    this.layerProtocol = layerProtocol;
  }

  public ResilienceConstraint restorePriority(String restorePriority) {
    this.restorePriority = restorePriority;
    return this;
  }

   /**
   * Get restorePriority
   * @return restorePriority
  **/
  @ApiModelProperty(value = "")
  public String getRestorePriority() {
    return restorePriority;
  }

  public void setRestorePriority(String restorePriority) {
    this.restorePriority = restorePriority;
  }

  public ResilienceConstraint isLockOut(Boolean isLockOut) {
    this.isLockOut = isLockOut;
    return this;
  }

   /**
   * The resource is configured to temporarily not be available for use in the protection scheme(s) it is part of. This overrides all other protection control states including forced. If the item is locked out then it cannot be used under any circumstances. Note: Only relevant when part of a protection scheme.
   * @return isLockOut
  **/
  @ApiModelProperty(value = "The resource is configured to temporarily not be available for use in the protection scheme(s) it is part of. This overrides all other protection control states including forced. If the item is locked out then it cannot be used under any circumstances. Note: Only relevant when part of a protection scheme.")
  public Boolean isIsLockOut() {
    return isLockOut;
  }

  public void setIsLockOut(Boolean isLockOut) {
    this.isLockOut = isLockOut;
  }

  public ResilienceConstraint isCoordinatedSwitchingBothEnds(Boolean isCoordinatedSwitchingBothEnds) {
    this.isCoordinatedSwitchingBothEnds = isCoordinatedSwitchingBothEnds;
    return this;
  }

   /**
   * Is operating such that switching at both ends of each flow acorss the FC is coordinated at both ingress and egress ends.
   * @return isCoordinatedSwitchingBothEnds
  **/
  @ApiModelProperty(value = "Is operating such that switching at both ends of each flow acorss the FC is coordinated at both ingress and egress ends.")
  public Boolean isIsCoordinatedSwitchingBothEnds() {
    return isCoordinatedSwitchingBothEnds;
  }

  public void setIsCoordinatedSwitchingBothEnds(Boolean isCoordinatedSwitchingBothEnds) {
    this.isCoordinatedSwitchingBothEnds = isCoordinatedSwitchingBothEnds;
  }

  public ResilienceConstraint isFrozen(Boolean isFrozen) {
    this.isFrozen = isFrozen;
    return this;
  }

   /**
   * Temporarily prevents any switch action to be taken and, as such, freezes the current state.  Until the freeze is cleared, additional near-end external commands are rejected and fault condition changes and received APS messages are ignored. All administrative controls of any aspect of protection are rejected.
   * @return isFrozen
  **/
  @ApiModelProperty(value = "Temporarily prevents any switch action to be taken and, as such, freezes the current state.  Until the freeze is cleared, additional near-end external commands are rejected and fault condition changes and received APS messages are ignored. All administrative controls of any aspect of protection are rejected.")
  public Boolean isIsFrozen() {
    return isFrozen;
  }

  public void setIsFrozen(Boolean isFrozen) {
    this.isFrozen = isFrozen;
  }

  public ResilienceConstraint reversionMode(ReversionModeEnum reversionMode) {
    this.reversionMode = reversionMode;
    return this;
  }

   /**
   * Indcates whether the protection scheme is revertive or non-revertive.
   * @return reversionMode
  **/
  @ApiModelProperty(value = "Indcates whether the protection scheme is revertive or non-revertive.")
  public ReversionModeEnum getReversionMode() {
    return reversionMode;
  }

  public void setReversionMode(ReversionModeEnum reversionMode) {
    this.reversionMode = reversionMode;
  }

  public ResilienceConstraint holdOffTime(String holdOffTime) {
    this.holdOffTime = holdOffTime;
    return this;
  }

   /**
   * This attribute indicates the time, in milliseconds, between declaration of signal degrade or signal fail, and the initialization of the protection switching algorithm.
   * @return holdOffTime
  **/
  @ApiModelProperty(value = "This attribute indicates the time, in milliseconds, between declaration of signal degrade or signal fail, and the initialization of the protection switching algorithm.")
  public String getHoldOffTime() {
    return holdOffTime;
  }

  public void setHoldOffTime(String holdOffTime) {
    this.holdOffTime = holdOffTime;
  }

  public ResilienceConstraint resilienceType(ResilienceType resilienceType) {
    this.resilienceType = resilienceType;
    return this;
  }

   /**
   * Get resilienceType
   * @return resilienceType
  **/
  @ApiModelProperty(value = "")
  public ResilienceType getResilienceType() {
    return resilienceType;
  }

  public void setResilienceType(ResilienceType resilienceType) {
    this.resilienceType = resilienceType;
  }

  public ResilienceConstraint restorationCoordinateType(RestorationCoordinateTypeEnum restorationCoordinateType) {
    this.restorationCoordinateType = restorationCoordinateType;
    return this;
  }

   /**
   *  The coordination mechanism between multi-layers.
   * @return restorationCoordinateType
  **/
  @ApiModelProperty(value = " The coordination mechanism between multi-layers.")
  public RestorationCoordinateTypeEnum getRestorationCoordinateType() {
    return restorationCoordinateType;
  }

  public void setRestorationCoordinateType(RestorationCoordinateTypeEnum restorationCoordinateType) {
    this.restorationCoordinateType = restorationCoordinateType;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ResilienceConstraint resilienceConstraint = (ResilienceConstraint) o;
    return Objects.equals(this.maxSwitchTimes, resilienceConstraint.maxSwitchTimes) &&
        Objects.equals(this.waitToRevertTime, resilienceConstraint.waitToRevertTime) &&
        Objects.equals(this.layerProtocol, resilienceConstraint.layerProtocol) &&
        Objects.equals(this.restorePriority, resilienceConstraint.restorePriority) &&
        Objects.equals(this.isLockOut, resilienceConstraint.isLockOut) &&
        Objects.equals(this.isCoordinatedSwitchingBothEnds, resilienceConstraint.isCoordinatedSwitchingBothEnds) &&
        Objects.equals(this.isFrozen, resilienceConstraint.isFrozen) &&
        Objects.equals(this.reversionMode, resilienceConstraint.reversionMode) &&
        Objects.equals(this.holdOffTime, resilienceConstraint.holdOffTime) &&
        Objects.equals(this.resilienceType, resilienceConstraint.resilienceType) &&
        Objects.equals(this.restorationCoordinateType, resilienceConstraint.restorationCoordinateType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(maxSwitchTimes, waitToRevertTime, layerProtocol, restorePriority, isLockOut, isCoordinatedSwitchingBothEnds, isFrozen, reversionMode, holdOffTime, resilienceType, restorationCoordinateType);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ResilienceConstraint {\n");
    
    sb.append("    maxSwitchTimes: ").append(toIndentedString(maxSwitchTimes)).append("\n");
    sb.append("    waitToRevertTime: ").append(toIndentedString(waitToRevertTime)).append("\n");
    sb.append("    layerProtocol: ").append(toIndentedString(layerProtocol)).append("\n");
    sb.append("    restorePriority: ").append(toIndentedString(restorePriority)).append("\n");
    sb.append("    isLockOut: ").append(toIndentedString(isLockOut)).append("\n");
    sb.append("    isCoordinatedSwitchingBothEnds: ").append(toIndentedString(isCoordinatedSwitchingBothEnds)).append("\n");
    sb.append("    isFrozen: ").append(toIndentedString(isFrozen)).append("\n");
    sb.append("    reversionMode: ").append(toIndentedString(reversionMode)).append("\n");
    sb.append("    holdOffTime: ").append(toIndentedString(holdOffTime)).append("\n");
    sb.append("    resilienceType: ").append(toIndentedString(resilienceType)).append("\n");
    sb.append("    restorationCoordinateType: ").append(toIndentedString(restorationCoordinateType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

