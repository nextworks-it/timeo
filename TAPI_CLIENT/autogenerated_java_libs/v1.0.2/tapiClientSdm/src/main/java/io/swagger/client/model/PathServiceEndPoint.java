/*
 * tapi-sdm API
 * tapi-sdm API generated from tapi-sdm.yang
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.swagger.client.model.Capacity;
import io.swagger.client.model.LocalClass;
import io.swagger.client.model.NameAndValue;
import io.swagger.client.model.ServiceInterfacePointRef;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * The association of the FC to LTPs is made via EndPoints. The EndPoint (EP) object class models the access to the FC function. The traffic forwarding between the associated EPs of the FC depends upon the type of FC and may be associated with FcSwitch object instances. In cases where there is resilience the EndPoint may convey the resilience role of the access to the FC. It can represent a protected (resilient/reliable) point or a protecting (unreliable working or protection) point. The EP replaces the Protection Unit of a traditional protection model. The ForwadingConstruct can be considered as a component and the EndPoint as a Port on that component
 */
@ApiModel(description = "The association of the FC to LTPs is made via EndPoints. The EndPoint (EP) object class models the access to the FC function. The traffic forwarding between the associated EPs of the FC depends upon the type of FC and may be associated with FcSwitch object instances. In cases where there is resilience the EndPoint may convey the resilience role of the access to the FC. It can represent a protected (resilient/reliable) point or a protecting (unreliable working or protection) point. The EP replaces the Protection Unit of a traditional protection model. The ForwadingConstruct can be considered as a component and the EndPoint as a Port on that component")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2019-07-09T13:10:07.918+02:00")
public class PathServiceEndPoint {
  @SerializedName("local-id")
  private String localId = null;

  @SerializedName("name")
  private List<NameAndValue> name = null;

  @SerializedName("direction")
  private String direction = null;

  @SerializedName("layer-protocol-qualifier")
  private String layerProtocolQualifier = null;

  @SerializedName("capacity")
  private Capacity capacity = null;

  @SerializedName("layer-protocol-name")
  private String layerProtocolName = null;

  @SerializedName("role")
  private String role = null;

  @SerializedName("service-interface-point")
  private ServiceInterfacePointRef serviceInterfacePoint = null;

  public PathServiceEndPoint localId(String localId) {
    this.localId = localId;
    return this;
  }

   /**
   * Get localId
   * @return localId
  **/
  @ApiModelProperty(value = "")
  public String getLocalId() {
    return localId;
  }

  public void setLocalId(String localId) {
    this.localId = localId;
  }

  public PathServiceEndPoint name(List<NameAndValue> name) {
    this.name = name;
    return this;
  }

  public PathServiceEndPoint addNameItem(NameAndValue nameItem) {
    if (this.name == null) {
      this.name = new ArrayList<NameAndValue>();
    }
    this.name.add(nameItem);
    return this;
  }

   /**
   * List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity.
   * @return name
  **/
  @ApiModelProperty(value = "List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity.")
  public List<NameAndValue> getName() {
    return name;
  }

  public void setName(List<NameAndValue> name) {
    this.name = name;
  }

  public PathServiceEndPoint direction(String direction) {
    this.direction = direction;
    return this;
  }

   /**
   * The orientation of defined flow at the EndPoint.
   * @return direction
  **/
  @ApiModelProperty(value = "The orientation of defined flow at the EndPoint.")
  public String getDirection() {
    return direction;
  }

  public void setDirection(String direction) {
    this.direction = direction;
  }

  public PathServiceEndPoint layerProtocolQualifier(String layerProtocolQualifier) {
    this.layerProtocolQualifier = layerProtocolQualifier;
    return this;
  }

   /**
   * Get layerProtocolQualifier
   * @return layerProtocolQualifier
  **/
  @ApiModelProperty(value = "")
  public String getLayerProtocolQualifier() {
    return layerProtocolQualifier;
  }

  public void setLayerProtocolQualifier(String layerProtocolQualifier) {
    this.layerProtocolQualifier = layerProtocolQualifier;
  }

  public PathServiceEndPoint capacity(Capacity capacity) {
    this.capacity = capacity;
    return this;
  }

   /**
   * Get capacity
   * @return capacity
  **/
  @ApiModelProperty(value = "")
  public Capacity getCapacity() {
    return capacity;
  }

  public void setCapacity(Capacity capacity) {
    this.capacity = capacity;
  }

  public PathServiceEndPoint layerProtocolName(String layerProtocolName) {
    this.layerProtocolName = layerProtocolName;
    return this;
  }

   /**
   * Get layerProtocolName
   * @return layerProtocolName
  **/
  @ApiModelProperty(value = "")
  public String getLayerProtocolName() {
    return layerProtocolName;
  }

  public void setLayerProtocolName(String layerProtocolName) {
    this.layerProtocolName = layerProtocolName;
  }

  public PathServiceEndPoint role(String role) {
    this.role = role;
    return this;
  }

   /**
   * Each EP of the FC has a role (e.g., working, protection, protected, symmetric, hub, spoke, leaf, root)  in the context of the FC with respect to the FC function. 
   * @return role
  **/
  @ApiModelProperty(value = "Each EP of the FC has a role (e.g., working, protection, protected, symmetric, hub, spoke, leaf, root)  in the context of the FC with respect to the FC function. ")
  public String getRole() {
    return role;
  }

  public void setRole(String role) {
    this.role = role;
  }

  public PathServiceEndPoint serviceInterfacePoint(ServiceInterfacePointRef serviceInterfacePoint) {
    this.serviceInterfacePoint = serviceInterfacePoint;
    return this;
  }

   /**
   * Get serviceInterfacePoint
   * @return serviceInterfacePoint
  **/
  @ApiModelProperty(value = "")
  public ServiceInterfacePointRef getServiceInterfacePoint() {
    return serviceInterfacePoint;
  }

  public void setServiceInterfacePoint(ServiceInterfacePointRef serviceInterfacePoint) {
    this.serviceInterfacePoint = serviceInterfacePoint;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PathServiceEndPoint pathServiceEndPoint = (PathServiceEndPoint) o;
    return Objects.equals(this.localId, pathServiceEndPoint.localId) &&
        Objects.equals(this.name, pathServiceEndPoint.name) &&
        Objects.equals(this.direction, pathServiceEndPoint.direction) &&
        Objects.equals(this.layerProtocolQualifier, pathServiceEndPoint.layerProtocolQualifier) &&
        Objects.equals(this.capacity, pathServiceEndPoint.capacity) &&
        Objects.equals(this.layerProtocolName, pathServiceEndPoint.layerProtocolName) &&
        Objects.equals(this.role, pathServiceEndPoint.role) &&
        Objects.equals(this.serviceInterfacePoint, pathServiceEndPoint.serviceInterfacePoint);
  }

  @Override
  public int hashCode() {
    return Objects.hash(localId, name, direction, layerProtocolQualifier, capacity, layerProtocolName, role, serviceInterfacePoint);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PathServiceEndPoint {\n");
    
    sb.append("    localId: ").append(toIndentedString(localId)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    direction: ").append(toIndentedString(direction)).append("\n");
    sb.append("    layerProtocolQualifier: ").append(toIndentedString(layerProtocolQualifier)).append("\n");
    sb.append("    capacity: ").append(toIndentedString(capacity)).append("\n");
    sb.append("    layerProtocolName: ").append(toIndentedString(layerProtocolName)).append("\n");
    sb.append("    role: ").append(toIndentedString(role)).append("\n");
    sb.append("    serviceInterfacePoint: ").append(toIndentedString(serviceInterfacePoint)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

